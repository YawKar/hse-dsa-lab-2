# Performance Comparison Lab №2
This file is available in languages: [**English**✅](README.md), [Russian](README_RU.md)

The objective of this laboratory work is to compare the performance of multiple algorithms designed to respond in real-time to queries regarding the number of rectangles that a given point (x, y) belongs to.

# Table of contents
1. [Problem Statement and Constraints](#problem-statement-and-constraints)
    - [Problem Statement](#problem-statement)
    - [Constraints](#constraints)
        1. [Rectangles](#rectangles)
        2. [Points](#points)
2. [Utilized Software Toolset](#utilized-software-toolset)
    - [C++](#c)
    - [Conan 2.0](#conan-20)
    - [CMake](#cmake)
    - [Google Benchmark](#google-benchmark)
3. [Test Case Generation](#test-case-generation)
4. [First Approach: Naive Brute Force Algorithm](#first-approach-naive-brute-force-algorithm)
5. [Second Approach: Compressed Coordinate Map Construction](#second-approach-compressed-coordinate-map-construction)
6. [Third Approach: Persistent Segment Tree on Compressed Coordinates](#third-approach-persistent-segment-tree-on-compressed-coordinates)
7. [Benchmark Graphs, Comparison, and Thoughts](#benchmark-graphs-comparison-and-thoughts)
8. [Installation](#installation)

# Problem Statement and Constraints
## Problem statement
Given rectangles on a two-dimensional plane, the task is to respond as quickly as possible to the query "How many rectangles does the point (x,y) belong to?".

## Constraints
### Rectangles
Each rectangle is defined by a pair of coordinates of its bottom-left and top-right corners: `x1 y1 x2 y2`.

Where `x1`, `y1`, `x2`, `y2` satisfy the following conditions:
- `x1, y1, x2, y2` are integers
- `0 <= x1, y1, x2, y2 <= 1e9`
- `x1 < x2`
- `y1 < y2`

C++ `Rectangle` class implementation:
```cpp
class Rectangle {
public:
    Point leftDown;
    Point rightUp;

    Rectangle(int x1, int y1, int x2, int y2) : leftDown(x1, y1), rightUp(x2, y2) {}
    Rectangle(const Point& leftDown_, const Point& rightUp_) : leftDown(leftDown_), rightUp(rightUp_) {}
};
```

### Points
Each point is defined by a pair of its coordinates: `x y`.

Where `x` and `y` satisfy the following conditions:
- `x, y` are integers
- `-1e9 <= x, y <= 1e9`
C++ `Point` class implementation:
```cpp
class Point {
public:
    int x;
    int y;

    Point(int x_ = 0, int y_ = 0) : x(x_), y(y_) {}
};
```

# Utilized Software Toolset
## C++
To conduct the laboratory work, the compiled language C++ was chosen. 
The C++ language was used to implement the algorithms. The version of the compiler used was GCC 11.3.0. The compilation flags were set to `-O3` to enable maximum optimization. The program was run on a machine with the following specifications:
| Property       | Value                                     |
|:---------------|------------------------------------------:|
| Architecture   | x86_64                                    |
| CPU op-mode(s) | 32-bit, 64-bit                            |
| Address sizes  | 39 bits physical, 48 bits virtual         |
| Byte Order     | Little Endian                             |
| CPU(s)         | 12                                        |
| Vendor ID      | GenuineIntel                              |
| Model name     | Intel(R) Core(TM) i7-10750H CPU @ 2.60GHz |
| CPU max MHz    | 5000,0000                                 |
| CPU min MHz    | 800,0000                                  |
| Virtualization | VT-x                                      |
| Cache (L1d)    | 192 KiB (6 instances)                     |
| Cache (L1i)    | 192 KiB (6 instances)                     |
| Cache (L2)     | 1,5 MiB (6 instances)                     |
| Cache (L3)     | 12 MiB (1 instance)                       |

An alternative in the form of Java was also considered, but it was decided to abandon it due to the uncertainty and noise that various runtime optimizations (warming up) and garbage collection introduce into measurements. Configuring the JVM for benchmarking is quite difficult and requires a proper level of expertise, which I'm afraid I don't have.

## Conan 2.0
For the convenience of development, source distribution, and library dependency management, I decided to use the modern package manager Conan 2.0. Thanks to it, to connect all dependencies and run the project, it is necessary to execute only a limited set of commands, which, after initial configuration of Conan, will be reduced to 2 commands: `cmake --build .`, `./lab_benchmark`.

## CMake
The project's build system is based on the industry standard - CMake. The .cmake files generated by Conan are used for building.

## Google Benchmark
I'm using the [Google Benchmark library](https://github.com/google/benchmark) for benchmarks, which I've included via Conan. It has a wide API and is very easy to use.

# Test Case Generation
To generate test cases for the problem, it was suggested to generate rectangles according to a certain rule:
- The recommended approach for generating a test set of rectangles is to use a set of nested rectangles with coordinates that have a step size greater than 1, such as `{(10*i, 10*i), (10*(2*N-i), 10*(2*N-i))}`.

As for generating points, it was advised to generate them somehow uniformly across the entire plane.

I decided to encapsulate test generation logic inside of the `TestCaseGenerator` class:
```cpp
class TestCaseGenerator {
public:
    static std::vector<Rectangle> generateRecommendedRectangles(int rectangles);
    static std::vector<Point> generateUniformlyDistributedPoints(
        int numberOfPoints, 
        int minX, 
        int maxX, 
        int minY, 
        int maxY, 
        int xSeed = std::random_device()(), 
        int ySeed = std::random_device()());
};
```
Implementation of `generateRecommendedRectangles`:
```cpp
std::vector<Rectangle> TestCaseGenerator::generateRecommendedRectangles(int numberOfRectangles) {
    std::vector<Rectangle> rects;
    rects.reserve(numberOfRectangles);
    for (int i = 0; i < numberOfRectangles; ++i) {
        rects.emplace_back(10 * i, 10 * i, 10 * (2 * numberOfRectangles - i), 10 * (2 * numberOfRectangles - i));
    }
    return rects;
}
```
Implementation of `generateUniformlyDistributedPoints`:
```cpp
std::vector<Point> TestCaseGenerator::generateUniformlyDistributedPoints(int numberOfPoints, int minX, int maxX, int minY, int maxY, int xSeed, int ySeed) {
    std::mt19937 xEngine(xSeed);
    std::mt19937 yEngine(ySeed);
    std::uniform_int_distribution<int> xDist(minX, maxX);
    std::uniform_int_distribution<int> yDist(minY, maxY);

    std::vector<Point> points;
    points.reserve(numberOfPoints);
    for (int i = 0; i < numberOfPoints; ++i) {
        points.emplace_back(xDist(xEngine), yDist(yEngine));
    }
    return points;
}
```

# First Approach: Naive Brute Force Algorithm
The first approach does not involve any data preprocessing. All rectangles are stored in a vector "as is". To obtain the answer for a specific point, we iterate over all rectangles and check two conditions: whether the given point is within this rectangle on both axes.

As I've mentioned before, there is no data preprocessing:
```cpp
void NaiveRectangleEnumeration::buildInternals() {}
```
The brute force implementation of query:
```cpp
int NaiveRectangleEnumeration::queryPoint(const Point& point)
{
    int answer = 0;
    for (const auto& rectangle : this->rectangles) {
        if (rectangle.leftDown.x <= point.x && point.x <= rectangle.rightUp.x &&
            rectangle.leftDown.y <= point.y && point.y <= rectangle.rightUp.y) {
                ++answer;
        }
    }
    return answer;
}
```

# Second Approach: Compressed Coordinate Map Construction
The second approach involves compressing the coordinates of all the rectangle points along both axes. We create a two-dimensional array over the compressed points, initially filled with zeros. Then, for each rectangle, we add `1` to each cell of the two-dimensional array that is located under the rectangle. As a result, we obtain a "height map", where the value of `map[i][j]` equals the number of rectangles that cover the two-dimensional compressed subspace at the point `(i, j)`.

To find the answer for a given point `(x, y)`, we will search for the indexes of the compressed coordinates along both axes. Specifically, we will look for **the largest compressed coordinate that is less than or equal to** the corresponding coordinate of the point. Once we find the compressed coordinates of the point, we check whether the point is inside the working area. If it is, we simply return the value of `map[zipped.x][zipped.y]`. Otherwise, the point is outside the bounds of the working area, and the answer is `0`.

Implementation of coordinate compression and map building:
```cpp
void QubicMapBuilding::buildInternals() {
    for (const auto& rect : this->rectangles) {
        this->zippedXs.push_back(rect.leftDown.x);  // Here we accumulate all x-es
        this->zippedXs.push_back(rect.rightUp.x);   // 
        this->zippedYs.push_back(rect.leftDown.y);  // and y-es of both rectangle corners
        this->zippedYs.push_back(rect.rightUp.y);
    }
    
    // Next, we need to sort these coordinates in order to effectively delete duplicates
    std::sort(this->zippedXs.begin(), this->zippedXs.end());
    std::sort(this->zippedYs.begin(), this->zippedYs.end());
    this->zippedXs.erase(std::unique(this->zippedXs.begin(), this->zippedXs.end()), this->zippedXs.end());
    this->zippedYs.erase(std::unique(this->zippedYs.begin(), this->zippedYs.end()), this->zippedYs.end());

    // Allocate two-dimensional map with '0' as default value
    this->map.resize(zippedXs.size());
    for (std::size_t i = 0; i < zippedXs.size(); ++i) {
        this->map[i].resize(this->zippedYs.size());
    }

    // This takes O(n^3) operations to build the final "height map".
    for (const auto& rect : this->rectangles) {
        Point zippedLeftDown(findPos(this->zippedXs, rect.leftDown.x), findPos(this->zippedYs, rect.leftDown.y));
        Point zippedRightUp(findPos(this->zippedXs, rect.rightUp.x), findPos(this->zippedYs, rect.rightUp.y));
        for (int xIdx = zippedLeftDown.x; xIdx < zippedRightUp.x + 1; ++xIdx) {
            for (int yIdx = zippedLeftDown.y; yIdx < zippedRightUp.y + 1; ++yIdx) {
                ++this->map[xIdx][yIdx];
            }
        }
    }
}
```

# Third Approach: Persistent Segment Tree on Compressed Coordinates

# Benchmark Graphs, Comparison, and Thoughts

# Installation
## How to setup and run
1. Install conan 2.0
2. [Optional] Create conan profile if you haven't yet: `conan profile detect --force`. This will create new default profile for conan in your system.
3. Install CMake of version not less than the one that is specified in CMakeLists.txt
3. `cd` to the root folder of the project
4. `conan install . --output-folder=build --build=missing`
5. `cd build`
6. `cmake .. -DCMAKE_TOOLCHAIN_FILE=conan_toolchain.cmake -DCMAKE_BUILD_TYPE=Release`
7. `cmake --build .`
8. `./conan_template`

Now make a tea and eat some cookies. You're awesome.
